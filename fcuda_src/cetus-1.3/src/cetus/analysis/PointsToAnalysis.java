package cetus.analysis;

import cetus.analysis.PointsToDomain.Universe;
import cetus.hir.*;
import cetus.transforms.NormalizeReturn;
import cetus.transforms.TransformPass;

import java.util.*;

/**
* The Points-To Analyzer creates intraprocedural pointer relationships for C
* programs. Pointer variables are variables that store the address-value of a
* memory location and are said to point-to or reference that memory location.
* The points-to analyzer implemented here is flow sensitive and hence, provides
* pointer relationships at every program point i.e. every relevant Statement in
* the program. Pointer relationships are represented using
* {@link PointsToDomain} and {@link PointsToRel}, which make use of different 
* {@link Symbol} information to a large extent. Aggregate structures such as
* arrays are handled conservatively, while struct types are handled more
* precisely. The analyzer also supports useful, but conservative, information
* handling for heap-allocated variables.
* <p>
* The analyzer is directly used by the Interprocedural Points-to Analyzer, to
* provide advanced static-time pointer information. Thus, function calls inside
* of procedures can be supported during intraprocedural analysis.
* <p>
* The analysis is implemented based on the design described in the following
* M.S. Thesis:
* <p>
* "A Practical Interprocedural Alias Analysis for an 
* Optimizing/Parallelizing C Compiler", Maryam Emami, 1993.
* 
* @see PointsToDomain
* @see PointsToRel
* @see IPPointsToAnalysis
*/
public class PointsToAnalysis extends AnalysisPass {

    private static final Set<String> standard_lib_pointers =
            new HashSet<String>(Arrays.asList("stdin", "stdout", "stderr"));

    private static final Set<Specifier> ignorable_specs =
            new HashSet<Specifier>(Arrays.asList(
                    Specifier.BOOL, Specifier.BOOLEAN, Specifier.BYTE,
                    Specifier.CBOOL, Specifier.CCOMPLEX, Specifier.CIMAGINARY));

    private static final Set<BinaryOperator> binary_ops =
            new HashSet<BinaryOperator>(Arrays.asList(
                    BinaryOperator.ADD,
                    BinaryOperator.SUBTRACT,
                    BinaryOperator.BITWISE_AND,
                    BinaryOperator.BITWISE_EXCLUSIVE_OR,
                    BinaryOperator.BITWISE_INCLUSIVE_OR,
                    BinaryOperator.DIVIDE,
                    BinaryOperator.MODULUS,
                    BinaryOperator.MULTIPLY,
                    BinaryOperator.SHIFT_LEFT,
                    BinaryOperator.SHIFT_RIGHT));

    public PointsToAnalysis(Program program) {
        super(program);
    }
    
    public String getPassName() {
        return "[POINTS-TO-ANALYSIS]";
    }

    /**
    * Simple intraprocedural analysis can be run for a procedure that does not
    * have pointers in formal parameters. Use only for simple testing or
    * understanding. Annotates the output source code with pointer-relationship
    * information. 
    * <p>
    * For complete use of points-to information, use interprocedural points-to
    * analysis, which directly uses information generated by the
    * intraprocedural analyzer.
    */
    public void start() {
        // IR Normalization passes for Points To analysis
        TransformPass.run(new NormalizeReturn(program));
        List<Procedure> proc_list = IRTools.getProcedureList(program);
        for (Procedure proc : proc_list) {
            Map map = getPointsToRelations(proc);
            annotatePointsTo(proc, map);
        }
    }

    /**
    * Use during interprocedural points-to analysis to get points-to relations
    * for the current procedure node {@link IPANode}. Returns map from each
    * statement in the procedure to points-to relationships at(right before)
    * the statement is executed
    * @param proc_node Procedure Node analyzed for points to information
    * @return Map from statement to points-to domain
    * @see PointsToDomain
    */
    protected static Map getPointsToRelations(IPANode proc_node) {
        Procedure proc = proc_node.getProcedure();
        // Create a map to store points-to information at each 
        // program point. This map is from a Statement to the 
        // pointer information that exists before the statement.
        LinkedHashMap stmt_rel_domain = new LinkedHashMap<Statement, Domain>();
        // Build a control flow graph for the procedure, for flow-
        // sensitive analysis
        CFGraph cfg = new CFGraph(proc);
        DFANode entry = cfg.getNodeWith("stmt", "ENTRY");
        // Maintain a list of nodes that must be processed for points 
        // to information. Nodes are processed in reverse post-order 
        // as provided by topological ordering (optimized)
        TreeMap<Integer, DFANode> node_list = new TreeMap<Integer, DFANode>();
        // Add all the nodes to the work-list, this takes care of the
        // first pass through the cfg in topological order.
        // Later, only successors for nodes that have different in and
        // out points-to domains are added back to the work list for 
        // subsequent iterations
        // =========================================================
        cfg.topologicalSortOptimized(entry);
        node_list.clear();
        Iterator<DFANode> iter = cfg.iterator();
        while (iter.hasNext()) {
            DFANode node = iter.next();
            node_list.put((Integer) node.getData("top-order"), node);
        }
        stmt_rel_domain = traverseWorkList(proc_node, node_list);
        // =========================================================
        return stmt_rel_domain;
    }

    /**
    * Uses worklist based traversal to iterate over all the nodes in the
    * control flow graph until a fixed-point is reached i.e. there is no change
    * in information from the previous iteration to the current.
    */
    private static LinkedHashMap traverseWorkList(
            IPANode proc_node, TreeMap<Integer, DFANode> node_list) {
        Procedure proc = proc_node.getProcedure();
        // Create a map to store points-to information at each 
        // program point. This map is from a Statement to the 
        // pointer information that exists before the statement.
        LinkedHashMap<Statement, Domain> stmt_rel_domain =
                new LinkedHashMap<Statement, Domain>();
        // Points-to Domains that are used during the 
        // data-flow update
        // IN
        Domain in_domain = null;
        // OUT
        Domain out_domain = null;
        // Domain to hold information generated by initializers
        // inside new scope
        Domain enterscope_domain = null;
        while (!node_list.isEmpty()) {
            Integer node_index = node_list.firstKey();
            DFANode curr_node = node_list.remove(node_index);
            // Unreachable node should be skipped.
            if ((Integer)curr_node.getData("top-order") < 0) {
                continue;
            }
            // ----------------- IN DOMAIN ---------------------------
            // Found an entry node, create empty points to set
            if (curr_node.getPreds().isEmpty()) {
                // Entry node points-to information must be mapped 
                // from what gets passed into the procedure
                // This could be passed in from various call sites
                // If we're doing context-insensitive analysis, these 
                // incoming data must be "merged" conservatively
                // Currently using the functionality provided by 
                // IPANode in(). See IPPointsToAnalysis for more 
                // information
                in_domain = proc_node.in();
                if (in_domain == null) {
                    in_domain = new NullDomain();
                }
            } else {
                in_domain = null;
            }
            // Get points-to information for predecessors, merge 
            // and update IN for this node
            for (DFANode pred : curr_node.getPreds()) {
                Domain pred_domain = (Domain)pred.getData("points-to");
                // Predecessor domain data is null, must be coming from a
                // back edge
                if (pred_domain == null) {
                    continue;
                }
                if (curr_node.getPreds().size() == 1 || in_domain == null) {
                    in_domain = pred_domain.clone();
                } else {
                    in_domain = PointsToDomain.merge(in_domain, pred_domain);
                }
            }
            // --------------------- INITIALIZER RELATED --------------------
            // Having determined in_domain, check if this node is entry 
            // point for new scope
            // If this node is also a symbol table entry point
            // i.e. creation of new scope, then
            // do points-to information preprocessing for pointer
            // initialization in the entry declarations for this 
            // scope. This is accessed via "symbol-entry"
            enterscope_domain = enterScope(
                    curr_node, in_domain, proc_node, stmt_rel_domain);
            if (enterscope_domain != null) {
                // Update IN if necessary
                in_domain = enterscope_domain.clone();
            }
            // --------------------- STATEMENT POINTS TO INFO ---------------
            // First get the statement object to which the current incoming
            // points-to information must be attached 
            Object s_stmt = curr_node.getData("stmt");
            if (s_stmt != null && s_stmt != "ENTRY") {
                stmt_rel_domain.put((Statement)s_stmt, in_domain);
            }
            // Get the ir associated with the current node, analyze for
            // points-to information if statement
            // One case where this distinction between "ir" and "stmt" must
            // be made is ForLoop where the entry node for the ForLoop 
            // contains the entire loop for "stmt" and hence must be used 
            // for attachment of points-to domain but contains the
            // initialization statement for "ir" which must be analyzed for
            // points-to updates
            Object s_ir = curr_node.getData("ir");
            // ---------------- OUT DOMAIN ----------------------------------
            // Only process for ExpressionStatements, the assignment and 
            // function call constructs we're especially interested in 
            // come as children of ExpressionStatement
            if (s_ir instanceof ExpressionStatement &&
                !(in_domain instanceof Universe) &&
                !(in_domain instanceof NullDomain)) {
                // Process the points to relations for this stmt
                out_domain = basicPointsTo(curr_node, in_domain, proc_node);
            } else {
                out_domain = in_domain.clone();
            }
            // Add the successors of this node if there is an update in the 
            // points to relations
            Domain last_domain = curr_node.getData("points-to");
            if (last_domain == null || !out_domain.equals(last_domain)) {
                for (DFANode succ : curr_node.getSuccs()) {
                    node_list.put((Integer)succ.getData("top-order"), succ);
                }
            }
            curr_node.putData("points-to", out_domain);
        }
        return stmt_rel_domain;
    }

    /**
    * For intraprocedural points-to analysis, first create a control flow graph
    * of the procedure. Traverse each statement in the CFG (each node in
    * CFGraph). Provide statement and input relationships to points-to
    * algorithm. Obtain output set of points to relationships. Propagate
    * forward and iterate over the CFG until all nodes have been analyzed and a
    * fixed point is reached.
    */
    private static Map getPointsToRelations(Procedure proc) {
        // Points to sets
        Domain in_domain = null;
        Domain out_domain = null;
        // At each program point
        LinkedHashMap<Statement, Domain> stmt_rel_domain =
                new LinkedHashMap<Statement, Domain>();
        // Domain to hold information generated by initializers
        // inside new scope
        Domain enterscope_domain = null;
        // Build a control flow graph for the procedure
        CFGraph cfg = new CFGraph(proc);
        DFANode entry = cfg.getNodeWith("stmt", "ENTRY");
        cfg.topologicalSort(entry);
        // Maintain a list of nodes that must be processed for points 
        // to information. Nodes are processed in reverse post-order 
        // as provided by topological ordering
        TreeMap<Integer, DFANode> node_list = new TreeMap<Integer, DFANode>();
        // Add all the nodes to the work-list, this takes care of the
        // first pass through the cfg in topological order.
        // Later, only successors for nodes that have different in and
        // out points to domains are added back to the work list for 
        // another pass
        Iterator<DFANode> iter = cfg.iterator();
        while (iter.hasNext()) {
            DFANode node = iter.next();
            node_list.put((Integer) node.getData("top-order"), node);
        }
        while (!node_list.isEmpty()) {
            Integer node_index = node_list.firstKey();
            DFANode curr_node = node_list.remove(node_index);
            // Found an entry node, create empty points to set
            if (curr_node.getPreds().isEmpty()) {
                // Entry node points to information must be mapped 
                // from what gets passed into the procedure
                // For "only" intra analysis, its empty
                in_domain = new PointsToDomain();
            } else {
                in_domain = null;
            }
            // Get points-to information for predecessors, merge 
            // and update for this statement
            for (DFANode pred : curr_node.getPreds()) {
                Domain pred_domain = pred.getData("points-to");
                // Predecessor domain data is null, must be coming from a
                // back edge
                if (pred_domain == null) {
                    //testSetBackEdge(curr_node);
                    continue;
                }
                if (curr_node.getPreds().size() == 1 || in_domain == null) {
                    in_domain = pred_domain.clone();
                } else {
                    in_domain = PointsToDomain.merge(in_domain, pred_domain);
                }
            }
            // Having determined in_domain, check if this node is entry 
            // point for new scope
            // If this node is also a symbol table entry point
            // i.e. creation of new scope, then
            // do points-to information preprocessing for pointer
            // initialization in the entry declarations for this 
            // scope. This is accessed via "symbol-entry"
            enterscope_domain =
                    enterScope(curr_node, in_domain, null, stmt_rel_domain);
            if (enterscope_domain != null) {
                in_domain = enterscope_domain.clone();
            }
            // Process the points to relations for this stmt
            // First get the statement object to which the current incoming
            // points-to information must be attached 
            Object s_stmt = curr_node.getData("stmt");
            if (s_stmt != null && s_stmt != "ENTRY") {
                stmt_rel_domain.put((Statement)s_stmt, in_domain);
            }
            // Get the ir associated with the current node, analyze for
            // points-to information if statement
            // One case where this distinction between "ir" and "stmt" must
            // be made is ForLoop where the entry node for the ForLoop 
            // contains the entire loop for "stmt" and hence must be used 
            // for attachment of points-to domain but contains the
            // initialization statement for "ir" which must be analyzed for
            // points-to updates
            Object s_ir = curr_node.getData("ir");
            if (s_ir instanceof ExpressionStatement &&
                !(in_domain instanceof Universe) &&
                !(in_domain instanceof NullDomain)) {
                out_domain = basicPointsTo(curr_node, in_domain, null);
            } else {
                out_domain = in_domain.clone();
            }
            // Add the successors of this node if there is an update in the 
            // points to relations
            Domain last_domain = curr_node.getData("points-to");
            if (last_domain == null || !out_domain.equals(last_domain)) {
                for (DFANode succ : curr_node.getSuccs()) {
                    node_list.put((Integer) succ.getData("top-order"), succ);
                }
            }
            curr_node.putData("points-to", out_domain);
        }
        return stmt_rel_domain;
    }

    /**
    * Handles the specific consideration of important constructs inside of
    * ExpressionStatements that we're interested in. Separately invokes
    * assignment updates and function call updates as required.
    */
    private static Domain
            basicPointsTo(DFANode node, Domain input, IPANode proc_node) {
        Statement stmt = null;
        Object s = node.getData("ir");
        if (s instanceof Statement) {
            stmt = (Statement)s;
        } else {
            return null;
        }
        Domain output = null;
        List<Traversable> t_list = stmt.getChildren();
        for (int i = 0; i < t_list.size(); i++) {
            Traversable t = t_list.get(i);
            // Check for points-to assignments for pointer 
            // expressions and update the points-to sets accordingly
            if (t instanceof AssignmentExpression) {
                AssignmentExpression assign = (AssignmentExpression)t;
                Expression lhs = assign.getLHS();
                Expression rhs = assign.getRHS();
                Symbol lhs_symbol = exprToLocation(lhs);
                if (lhs_symbol != null && SymbolTools.isPointer(lhs_symbol)) {
                    // Temporary elimintation to avoid any pointer 
                    // types that we do not consider.
                    List specs = lhs_symbol.getTypeSpecifiers();
                    for (Object spec : specs) {
                        if (ignorable_specs.contains(spec)) {
                            output = input.clone();
                            break;
                        }
                    }
                    // Normalization is important for simplifying 
                    // different corner cases as required by the 
                    // analysis
                    Expression lhs_normalized = normalizePointsTo(lhs);
                    Expression rhs_normalized = normalizePointsTo(rhs);
                    Domain assigned;
                    // ------------------ ASSIGNMENT HANDLING --------------
                    // If the rhs is a function call, use interprocedural
                    // information (if available)
                    if (IRTools.containsClass(rhs, FunctionCall.class)) {
                        // Intra-procedural analysis
                        if ((proc_node == null)) {
                            assigned = Universe.getUniverse();
                        } else {
                            // Use return value information for functions 
                            // that return pointers e.g. malloc
                            assigned = processFunctionAssignment(
                                    lhs_normalized, rhs, input, proc_node);
                        }
                    // If not a function call, we use the standard assignment
                    // handling routine
                    } else {
                        assigned = processBasicAssignment(
                                lhs_normalized, rhs_normalized, stmt, input);
                    }
                    if (output == null) {
                        output = assigned;
                    } else {
                        output = output.union(assigned);
                    }
                } else if (IRTools.containsClass(t, FunctionCall.class)) {
                    Domain ret;
                    ret = processFunctionUpdate(proc_node, t);
                    if (ret == null) {
                        output = input.clone();
                    } else {
                        output = ret;
                    }
                } else {
                    output = input.clone();
                }
                break;
            } else if (IRTools.containsClass(t, FunctionCall.class)) {
                Domain ret;
                ret = processFunctionUpdate(proc_node, t);
                if (ret == null) {
                    output = input.clone();
                } else {
                    output = ret;
                }
                break;
            } else {
                output = input.clone();
            }
        }
        return output;
    }

    /**
    * Core handling of pointer assignment. Uses computation of LHS location,
    * RHS location. GEN and KILL sets are created accordingly for the
    * assignment update, thus providing the OUT domain information.
    * @param lhs Normalized LHS expression in assignment
    * @param rhs Normalized RHS expression in assignment
    * @param stmt Parent IR statement 
    * @param input IN domain
    * @return output OUT domain
    */
    protected static Domain processBasicAssignment(
            Expression lhs, Expression rhs, Statement stmt, Domain input) {
        Domain output = null;
        boolean points_to_universe = false;
        // Check and handle pointer arithmetic if 
        // present in LHS or RHS
        if (checkPointerArithmetic(lhs)) {
            lhs = normalizePointerArithmetic(lhs);
            if (lhs == null) {
                output = Universe.getUniverse();
                return output;
            }
        }
        if (checkPointerArithmetic(rhs)) {
            rhs = normalizePointerArithmetic(rhs);
            if (rhs == null) {
                output = Universe.getUniverse();
                return output;
            }
        }
        // ----------------------- OBTAIN L-LOCATION SET -----------------------
        // ***x = &y
        // (*x)->y = &z
        // ***x and (*x)->y are expressions corresponding to L-locations
        Map<Symbol, Boolean> l_locations = new HashMap<Symbol, Boolean>();
        points_to_universe |= computeLlocations(l_locations, lhs, input);
        // ---------------------- DETERMINE TYPE ------------------------------
        // If the l-locations are pointer types, only then proceed with
        // points to analysis, else return input.clone()
        for (Symbol s : l_locations.keySet()) {
            if (PointsToAnalysis.isPointer(s)) {
                continue;
            }
            output = input.clone();
            return output;
        }
        if (l_locations.isEmpty() && !points_to_universe) {
            output = input.clone();
            return output;
        }
        // ------------------------ OBTAIN L-LOCATION KILL SET -----------------
        Map<Symbol, Boolean> l_locations_kill = new HashMap<Symbol, Boolean>();
        points_to_universe |=
                computeLlocationsKill(l_locations_kill, lhs, input);
        // Kill l_locations which eventually have 'definite' locations
        // associated with them
        Set<Symbol> killset = new HashSet<Symbol>();
        for (Symbol s : l_locations_kill.keySet()) {
            if (l_locations_kill.get(s)) {
                killset.add(s);
            }
        }
        Domain kill = null;
        if (input instanceof PointsToDomain) {
            kill = ((PointsToDomain)input).killSet(killset);
        // input has to be NullDomain in which case kill 
        // information doesn't need to be created
        // provide empty kill domain
        } else {
            kill = new PointsToDomain();
        }
        // Irrespective of whether input was PointsToDomain or NullDomain,
        // we can't determine what we're assigning to anymore. Hence return
        // output  for this statement as NullDomain
        if (points_to_universe) {
            output = Universe.getUniverse();
            return output;
        }
        // ----------------------- OBTAIN THE R-LOCATION SET -------------------
        // ***x = &y
        // (*x)->y = &z
        // y and z are expressions corresponding to R-locations
        Map<Symbol, Boolean> r_locations = new HashMap<Symbol, Boolean>();
        points_to_universe |= computeRlocations(r_locations, rhs, stmt, input);
        // If we're pointing to universe after failing to determine 
        // r-location, it means we can identify the l-location at 
        // least. Hence kill the relationships for the l-location
        // and return an updated version of the input with the 
        // l-locations killed
        if (points_to_universe) {
            output = Universe.getUniverse();
            return output;
        }
        // ------------------------ OBTAIN THE CHANGED INPUT SET ---------------
        Domain changed_input = null;
        if (input instanceof PointsToDomain) {
            PointsToDomain diff_domain = new PointsToDomain();
            PointsToDomain temp_domain = new PointsToDomain();
            for (Symbol pointer : l_locations.keySet()) {
                if (!l_locations.get(pointer)) {
                    HashSet<PointsToRel> rel_set =
                            ((PointsToDomain)input).get(pointer);
                    if (rel_set != null) {
                        for (PointsToRel p_rel : rel_set) {
                            if (p_rel.isDefinite()) {
                                diff_domain.addRel(p_rel);
                                PointsToRel new_rel = p_rel.clone();
                                new_rel.setPossible();
                                temp_domain.addRel(new_rel);
                            }
                        }
                    }
                }
            }
            changed_input = temp_domain.union(input.diffStrong(diff_domain));
        } else {
            changed_input = input;
        }
        // -------------------------- OBTAIN THE GEN SET -----------------------
        Domain gen = null;
        if (!(l_locations.isEmpty()) && !(r_locations.isEmpty())) {
            // Need to create new points to relationships
            gen = new PointsToDomain();
            for (Symbol pointer : l_locations.keySet()) {
                for (Symbol pointsto : r_locations.keySet()) {
                    PointsToRel new_rel = new PointsToRel(pointer, pointsto,
                            (l_locations.get(pointer) &&
                            r_locations.get(pointsto)));
                    ((PointsToDomain)gen).addRel(new_rel);
                }
            }
        } else if (input instanceof NullDomain || input instanceof Universe) {
            gen = input;
        } else {
            // No gen information for this statement
            gen = new PointsToDomain();
        }
        // ------------------------ OBTAIN THE OUTPUT SET ---------------------
        // OUT = GEN U (IN - KILL)
        output = gen.union(changed_input.diffStrong(kill));
        return output;
    }

    /**
    * Handles normalized lhs expressions and uses IN information to determine
    * L-locations. Pointer-chains are handled through iteration. Arrays are
    * treated conservatively as a single location with "P" possible
    * relationship. Returns points_to_universe = TRUE if unable to correctly 
    * determine l-location information
    */
    private static boolean computeLlocations(
            Map<Symbol, Boolean> l_locations, Expression lhs, Domain input) {
        boolean lhs_rel = true;
        boolean points_to_universe = false;
        // As we consider the entire array to be a single location, we only use
        // the name of the array to determine location information
        if (lhs instanceof ArrayAccess) {
            lhs = ((ArrayAccess)lhs).getArrayName();
            // Any pointer to the array has a P(possible) relation
            lhs_rel = false;
        }
        Symbol lhs_symbol = exprToLocation(lhs);
        HashMap<Symbol, Boolean> deref_symbols = new HashMap<Symbol, Boolean>();
        if (input instanceof PointsToDomain && lhs instanceof AccessExpression){
            AccessSymbol access_sym = new AccessSymbol((AccessExpression)lhs);
            Map<Symbol, Boolean> l_lhs_locations_search =
                    new HashMap<Symbol, Boolean>();
            Map<Symbol, Boolean> l_rhs_locations_search =
                    new HashMap<Symbol, Boolean>();
            if (access_sym.getBaseSymbol() instanceof DerefSymbol) {
                Expression base_exp = ((AccessExpression)lhs).getLHS();
                points_to_universe |= computeLlocations(
                        l_lhs_locations_search, base_exp, input);
            } else {
                l_lhs_locations_search.put(access_sym.getBaseSymbol(), true);
            }
            // The RHS of the access expression is always a member field
            // and thus its symbol is used as it is
            l_rhs_locations_search.put(access_sym.getMemberSymbol(), true);
            if (!points_to_universe) {
                for (Symbol base : l_lhs_locations_search.keySet()) {
                    for (Symbol member : l_rhs_locations_search.keySet()) {
                        AccessSymbol actual_struct =
                                new AccessSymbol(base, member);
                        l_locations.put(actual_struct,
                                        (l_lhs_locations_search.get(base) &&
                                         l_rhs_locations_search.get(member)));
                    }
                }
            }
        } else if (input instanceof PointsToDomain &&
                   lhs instanceof UnaryExpression) {
            int depth = 0;
            // If lhs is unary expression, its symbol will be
            // DerefSymbol always
            if (lhs_symbol instanceof DerefSymbol) {
                depth = ((DerefSymbol)lhs_symbol).getDepth();
                deref_symbols.put(
                        ((DerefSymbol)lhs_symbol).getVisibleSymbol(), lhs_rel);
            } else {
                points_to_universe = true;
                PrintTools.printlnStatus(3,
                    "ERROR: lhs unary expression doesn't give deref symbol");
            }
            while (depth > 0) {
                HashSet<PointsToRel> pointed_to = new HashSet<PointsToRel>();
                // For the current set of symbols, get their points to
                // relationships
                for (Symbol s : deref_symbols.keySet()) {
                    // They might not point to anything - INVALID CODE?
                    // If they're formal parameters/invisible variables?
                    if (((PointsToDomain)input).get(s) != null) {
                        pointed_to.addAll(((PointsToDomain)input).get(s));
                    } else if ((PointsToAnalysis.isPointer(lhs_symbol))) {
                        // Be a little more precise than just reassigning to 
                        // points to universe
                        // Try and check the type of the final lhs_location, 
                        // are we actually assigning to a pointer?
                        // If it is pointer-type, we are out of luck
                        points_to_universe = true;
                        break;
                    }
                }
                deref_symbols.clear();
                for (PointsToRel p_rel : pointed_to) {
                    deref_symbols.put(p_rel.getPointedToSymbol(),
                                      p_rel.isDefinite());
                }
                // if even one symbol in the deref set is not a pointer,
                // we assume we've been doing everything right and that
                // this isn't a pointer assignment statement
                // we've reached the end 
                // of a dereference chain to a variable location
                for (Symbol s : deref_symbols.keySet()) {
                    if (!(PointsToAnalysis.isPointer(s))) {
                        depth = 0;
                        break;
                    }
                }
                depth--;
            }
            // Add all finally arrived symbols to the l-location set
            l_locations.putAll(deref_symbols);
        // If input is instance of Universe, current points-to 
        // information is pointing to universe
        } else if ((input instanceof Universe) &&
                   lhs instanceof UnaryExpression) {
            // Leave l_locations empty, there is no strong update
            points_to_universe = true;
        } else if (input instanceof NullDomain) {
            l_locations.clear();
        // lhs is not a unary expression of type *x, 
        // just a pointer variable being assigned to
        // This is a strong update to the l-location
        } else {
            l_locations.put(lhs_symbol, lhs_rel);
        }
        return points_to_universe;
    }

    /**
    * See computeLlocations(). Special handling needed to avoid killing
    * l-location relationships with "P" type.
    */
    private static boolean computeLlocationsKill(
            Map<Symbol, Boolean> l_locations_kill, Expression lhs,
            Domain input) {
        boolean lhs_rel = true;
        boolean points_to_universe = false;
        // As we consider the entire array to be a single location, we only use
        // the name of the array to determine location information
        if (lhs instanceof ArrayAccess) {
            lhs = ((ArrayAccess)lhs).getArrayName();
            lhs_rel = false;
        }
        Symbol lhs_symbol = exprToLocation(lhs);
        // For arrays, we consider the whole array to be one single location
        // and hence any pointer to the array has a P(possible) relation
        //if (SymbolTools.isArray(lhs_symbol))
        //lhs_rel = false;
        Expression lhs_ref;
        HashMap<Symbol, Boolean> kill_symbols = new HashMap<Symbol, Boolean>();
        if (input instanceof PointsToDomain && lhs instanceof AccessExpression){
            AccessSymbol access_sym = new AccessSymbol((AccessExpression)lhs);
            Map<Symbol, Boolean> l_lhs_locations_search =
                    new HashMap<Symbol, Boolean>();
            Map<Symbol, Boolean> l_rhs_locations_search =
                    new HashMap<Symbol, Boolean>();
            if (access_sym.getBaseSymbol() instanceof DerefSymbol) {
                Expression base_exp = ((AccessExpression)lhs).getLHS();
                Expression base_local = base_exp.clone();
                //normalizePointsTo(base_exp);
                points_to_universe |= computeLlocations(
                        l_lhs_locations_search, base_exp, input);
            } else {
                l_lhs_locations_search.put(access_sym.getBaseSymbol(), true);
            }
            // The RHS of the access expression is always a member field
            // and thus its symbol is used as it is
            l_rhs_locations_search.put(access_sym.getMemberSymbol(), true);
            if (!points_to_universe) {
                for (Symbol base : l_lhs_locations_search.keySet()) {
                    for (Symbol member : l_rhs_locations_search.keySet()) {
                        AccessSymbol actual_struct =
                                new AccessSymbol(base, member);
                        l_locations_kill.put(actual_struct,
                                (l_lhs_locations_search.get(base) &&
                                l_rhs_locations_search.get(member)));
                    }
                }
            }
        } else if (input instanceof PointsToDomain &&
                   lhs instanceof UnaryExpression) {
            int depth = 0;
            if (lhs_symbol instanceof DerefSymbol) {
                depth = ((DerefSymbol)lhs_symbol).getDepth();
                kill_symbols.put(
                        ((DerefSymbol)lhs_symbol).getVisibleSymbol(), lhs_rel);
            }
            while (depth > 0) {
                HashSet<PointsToRel> pointed_to = new HashSet<PointsToRel>();
                // For the current set of symbols, get their points to
                // relationships
                for (Symbol s : kill_symbols.keySet()) {
                    // They might not point to anything - INVALID CODE?
                    // If they're formal parameters/invisible variables?
                    if (kill_symbols.get(s) &&
                        ((PointsToDomain)input).get(s) != null) {
                        pointed_to.addAll(((PointsToDomain) input).get(s));
                    } else if (((PointsToDomain) input).get(s) == null &&
                               (PointsToAnalysis.isPointer(lhs_symbol))) {
                        points_to_universe = true;
                        break;
                    }
                }
                kill_symbols.clear();
                for (PointsToRel p_rel : pointed_to) {
                    kill_symbols.put(p_rel.getPointedToSymbol(),
                                     p_rel.isDefinite());
                }
                // if even one symbol in the deref set is not a pointer,
                // we assume we've been doing everything right and that
                // this isn't a pointer assignment statement
                // we've reached the end 
                // of a dereference chain to a variable location
                for (Symbol s : kill_symbols.keySet()) {
                    if (!(PointsToAnalysis.isPointer(s))) {
                        depth = 0;
                        break;
                    }
                }
                depth--;
            }
            l_locations_kill.putAll(kill_symbols);
        // If input is Universe, and we have a unary expression,
        // we can't have a strong update
        } else if ((input instanceof Universe) &&
                   lhs instanceof UnaryExpression) {
            points_to_universe = true;
        // lhs is not a unary expression of type *x, 
        // just a pointer variable being assigned to
        // killSet in PointsToDomain will handle this
        } else {
            l_locations_kill.put(lhs_symbol, lhs_rel);
        }
        // Having identified all the symbols to be killed and their 
        // corresponding location relationships, we must now add to the
        // set all invisible symbols whose visible symbol relations are 
        // being killed
        // e.g. {p,*p,D},{*p,j,D}
        // p = &i;
        // {p,i,D} -> *p must be killed as well
        Map<Symbol, Boolean> invisible_locations_kill =
                new HashMap<Symbol, Boolean>();
        for (Symbol s : l_locations_kill.keySet()) {
            boolean inv_rel = l_locations_kill.get(s);
            Symbol inv_symbol = s;
            while ((inv_symbol = DerefSymbol.get(inv_symbol)) != null) {
                invisible_locations_kill.put(inv_symbol, inv_rel);
            }
        }
        l_locations_kill.putAll(invisible_locations_kill);
        return points_to_universe;
    }

    /**
    * Just use the l-location derivation for finding the r-locations
    * Handle special cases for RHS expressions
    * - NULL pointer int *x = NULL;
    * - StringLiterals char *c = "Hello World"
    * - Standard lib pointers stdout, stdin, stderr
    * Function calls handled by function update functionality
    */
    private static boolean computeRlocations(Map<Symbol, Boolean> r_locations,
            Expression rhs, Statement stmt, Domain input) {
        boolean points_to_universe = false;
        // ----------------------- NULL POINTER ASSIGNMENT CHECK ---------------
        if (isNullPointer(rhs)) {
            Expression null_loc = new NameID("nullloc");
            IPPointsToAnalysis.AbstractLocation sym =
                    IPPointsToAnalysis.AbstractLocation.getLocation(null_loc);
            //r_locations.clear();
            r_locations.put(sym, true);
        // ----------------------- CHARACTER STRING ASSIGNMENT CHECK -----------
        // ----------------------- OTHER ABSTRACT LOCATION CHECK ---------------
        } else if (rhs instanceof StringLiteral ||
                   standard_lib_pointers.contains(rhs.toString())) {
            IPPointsToAnalysis.AbstractLocation sym =
                    IPPointsToAnalysis.AbstractLocation.getLocation(rhs, stmt);
            r_locations.put(sym, true);
        // ----------------------- UNARY EXPRESSION CHECK -----------------
        } else {
            Expression unary_ref;
            HashMap<Symbol, Boolean> deref_symbols =
                    new HashMap<Symbol, Boolean>();
            // If address of, then r-location is the symbol itself
            if ((rhs instanceof UnaryExpression) &&
                (((UnaryExpression)rhs).getOperator() ==
                        UnaryOperator.ADDRESS_OF)) {
                UnaryExpression unary = (UnaryExpression)rhs;
                unary_ref = unary.getExpression();
            } else {
                unary_ref = rhs;
            }
            Map<Symbol, Boolean> r_lhs_locations_search =
                    new HashMap<Symbol, Boolean>();
            Expression unary_ref_local = unary_ref.clone();
            //normalizePointsTo(unary_ref);
            points_to_universe |=
                    computeLlocations(r_lhs_locations_search, unary_ref, input);
            deref_symbols.clear();
            deref_symbols.putAll(r_lhs_locations_search);
            // if not address of operation or not even
            // a unary expression, just identify the 
            // r-location in the same way as l-location and then
            // dereference once more to get the actual r-location
            if ((input instanceof PointsToDomain) &&
                (!(rhs instanceof UnaryExpression) ||
                 !(((UnaryExpression) rhs).getOperator() ==
                   UnaryOperator.ADDRESS_OF))) {
                HashSet<PointsToRel> pointed_to = new HashSet<PointsToRel>();
                HashMap<Symbol, Boolean> possible_heap_symbols =
                        new HashMap<Symbol, Boolean>();
                // For the current set of symbols, get their points to
                // relationships
                for (Symbol s : deref_symbols.keySet()) {
                    // They might not point to anything - INVALID CODE?
                    // If they're formal parameters/invisible variables?
                    if (((PointsToDomain) input).get(s) != null) {
                        pointed_to.addAll(((PointsToDomain)input).get(s));
                    } else if (s instanceof
                               IPPointsToAnalysis.AbstractLocation) {
                        ; // Do nothing, but don't create universe
                    } else if (s instanceof AccessSymbol &&
                               ((AccessSymbol)s).getBaseSymbol() instanceof
                               IPPointsToAnalysis.AbstractLocation) {
                        possible_heap_symbols.put(
                                ((AccessSymbol)s).getBaseSymbol(), false);
                    } else {
                        // If null, then points to universe
                        points_to_universe = true;
                    }
                }
                deref_symbols.clear();
                for (PointsToRel p_rel : pointed_to) {
                    deref_symbols.put(p_rel.getPointedToSymbol(),
                                      p_rel.isDefinite());
                }
                deref_symbols.putAll(possible_heap_symbols);
            } else if (!(rhs instanceof UnaryExpression) ||
                       !(((UnaryExpression) rhs).getOperator() ==
                       UnaryOperator.ADDRESS_OF)) {
                // We have a case where we need to dereference the rhs further,
                // but input isn't PointsToDomain
                points_to_universe = true;
            }
            // Add all finally arrived symbols to the r-location set
            r_locations.putAll(deref_symbols);
        }
        return points_to_universe;
    }

    /**
    * This provides data flow update to points-to information after calling a
    * function. Points-to information may be updated for parameters passed into
    * the function or for global variables. See processFunctionAssignment for
    * returned pointer values. Consequently, points-to information must be
    * generated or updated
    */
    private static Domain
            processFunctionUpdate(IPANode proc_node, Traversable t) {
        Domain update = null;
        // Find all function calls in this statement and process
        // them in semantic order
        LinkedList<FunctionCall> calls = new LinkedList<FunctionCall>();
        DFIterator<FunctionCall> iter =
                new DFIterator<FunctionCall>(t, FunctionCall.class);
        while (iter.hasNext()) {
            calls.addFirst(iter.next());
        }
        // if proc_node is null, we're performing intra analysis and hence
        // a function call must be handled conservatively and the 
        // return information must be points to universe
        if (proc_node == null) {
            return (Universe.getUniverse());
        }
        while (!calls.isEmpty()) {
            FunctionCall call = calls.remove();
            CallSite callsite = proc_node.getCallSite(call);
            Domain call_result = null;
            if (StandardLibrary.contains(call)) {
                return null;
            } else if (IPPointsToAnalysis.isSafeLibraryCall(call)) {
                return null;
            // User library call
            } else if (callsite.getCallee() == null) {
                return (Universe.getUniverse());
            } else {
                call_result = callsite.out();
            }
            if (update == null) {
                update = call_result.clone();
            } else {
                update = update.union(call_result);
            }
        }
        return update;
    }

    /**
    * Handles functions that return pointer values i.e. those appearing in
    * pointer assignment expressions
    */
    private static Domain processFunctionAssignment(
            Expression lhs, Expression rhs, Domain input, IPANode proc_node) {
        Domain output;
        Domain update = processFunctionUpdate(proc_node, rhs);
        if (update != null) {
            input = update;
        }
        boolean points_to_universe = false;
        // ----------------------- OBTAIN L-LOCATION SET -----------------------
        // ***x = &y
        // (*x)->y = &z
        Map<Symbol, Boolean> l_locations = new HashMap<Symbol, Boolean>();
        points_to_universe |= computeLlocations(l_locations, lhs, input);
        // ---------------------- DETERMINE TYPE ------------------------------
        // If the l-locations are pointer types, only then proceed with
        // points to analysis, else return input.clone()
        for (Symbol s : l_locations.keySet()) {
            if (PointsToAnalysis.isPointer(s)) {
                continue;
            }
            output = input.clone();
            return output;
        }
        if (l_locations.isEmpty() && !points_to_universe) {
            output = input.clone();
            return output;
        }
        // ------------------------ OBTAIN L-LOCATION KILL SET -----------------
        Map<Symbol, Boolean> l_locations_kill = new HashMap<Symbol, Boolean>();
        points_to_universe |=
                computeLlocationsKill(l_locations_kill, lhs, input);
        // Kill l_locations which eventually have 'definite' locations
        // associated with them
        Set<Symbol> killset = new HashSet<Symbol>();
        for (Symbol s : l_locations_kill.keySet()) {
            if (l_locations_kill.get(s)) {
                killset.add(s);
            }
        }
        Domain kill = null;
        if (input instanceof PointsToDomain) {
            kill = ((PointsToDomain)input).killSet(killset);
        // input has to be NullDomain in which case kill 
        // information doesn't need to be created
        // provide empty kill domain
        } else {
            kill = new PointsToDomain();
        }
        // Irrespective of whether input was PointsToDomain or NullDomain,
        // we can't determine what we're assigning to anymore. Hence return
        // output for this statement as NullDomain
        if (points_to_universe) {
            output = Universe.getUniverse();
            return output;
        }
        // ----------------------- OBTAIN THE R-LOCATION SET -------------------
        // Get the outermost function call in the rhs, this is the call site
        // that returns the value being assigned to the lhs
        DFIterator<FunctionCall> dfs_iter =
                new DFIterator<FunctionCall>(rhs, FunctionCall.class);
        FunctionCall call = dfs_iter.next();
        Map<Symbol, Boolean> r_locations = new HashMap<Symbol, Boolean>();
        Set<PointsToRel> return_result = null;
        return_result = IPPointsToAnalysis.getReturnRelations(
                proc_node.getCallSite(call));
        if (return_result != null) {
            for (PointsToRel p_rel : return_result) {
                r_locations.put(p_rel.getPointedToSymbol(), p_rel.isDefinite());
            }
        } else {
            points_to_universe = true;
        }
        // If we're pointing to universe after failing to determine 
        // r-location, it means we can identify the l-location at 
        // least. Hence kill the relationships for the l-location
        // and return an updated version of the input with the 
        // l-locations killed
        if (points_to_universe) {
            output = Universe.getUniverse();
            return output;
        }
        // ------------------------ OBTAIN THE CHANGED INPUT SET ---------------
        Domain changed_input = null;
        if (input instanceof PointsToDomain) {
            PointsToDomain diff_domain = new PointsToDomain();
            PointsToDomain temp_domain = new PointsToDomain();
            for (Symbol pointer : l_locations.keySet()) {
                if (!l_locations.get(pointer)) {
                    HashSet<PointsToRel> rel_set =
                            ((PointsToDomain)input).get(pointer);
                    if (rel_set != null) {
                        for (PointsToRel p_rel : rel_set) {
                            if (p_rel.isDefinite()) {
                                diff_domain.addRel(p_rel);
                                PointsToRel new_rel = p_rel.clone();
                                new_rel.setPossible();
                                temp_domain.addRel(new_rel);
                            }
                        }
                    }
                }
            }
            changed_input = temp_domain.union(input.diffStrong(diff_domain));
        } else {
            changed_input = input;
        }
        // -------------------------- OBTAIN THE GEN SET -----------------------
        Domain gen = null;
        if (!(l_locations.isEmpty()) && !(r_locations.isEmpty())) {
            // Need to create new points to relationships
            gen = new PointsToDomain();
            for (Symbol pointer : l_locations.keySet()) {
                for (Symbol pointsto : r_locations.keySet()) {
                    PointsToRel new_rel = new PointsToRel(pointer, pointsto,
                      (l_locations.get(pointer) && r_locations.get(pointsto)));
                    ((PointsToDomain)gen).addRel(new_rel);
                }
            }
        } else if (input instanceof NullDomain || input instanceof Universe) {
            gen = input;
        } else {
            // No gen information for this statement
            gen = new PointsToDomain();
        }
        // ------------------------ OBTAIN THE OUTPUT SET ---------------------
        output = gen.union(changed_input.diffStrong(kill));
        return output;
    }

    /**
    * In order to simplify points to analysis, normalize the expression
    * that might include pointers, dereferences, access expressions etc.
    * @param e The expression to be normalized
    * @return Expression with same symbols, but in normalized form
    */
    @SuppressWarnings("unchecked")
    protected static Expression normalizePointsTo(Expression e) {
        Expression e_clone = e.clone();
        Expression normalized = null;
        Map<Expression, Expression> swap_pairs =
                new HashMap<Expression, Expression>();
        DFIterator<Expression> iter =
                new DFIterator<Expression>(e, Expression.class);
        iter.pruneOn(AccessExpression.class);
        iter.pruneOn(ArrayAccess.class);
        while (iter.hasNext()) {
            Expression o = iter.next();
            if (o instanceof AccessExpression) {
                AccessExpression access = (AccessExpression)o;
                Expression lhs = normalizePointsTo(access.getLHS());
                Expression rhs = normalizePointsTo(access.getRHS());
                lhs.setParens(true);
                rhs.setParens(true);
                // Examples
                // (x).y
                // (*x).y
                // Examples
                // (x).(*y)
                if (access.getOperator() == AccessOperator.MEMBER_ACCESS) {
                    // Intermediate normalization step where we end up with
                    // x.(&y[0])
                    // This should be
                    // &(x.y[0])
                    if ((rhs instanceof UnaryExpression) &&
                        ((UnaryExpression)rhs).getOperator() ==
                                UnaryOperator.ADDRESS_OF) {
                        Expression acc;
                        rhs = ((UnaryExpression)rhs).getExpression();
                        if (rhs instanceof ArrayAccess) {
                            Expression normalized_name = normalizePointsTo(
                                    ((ArrayAccess)rhs).getArrayName());
                            List<Expression> indices =
                                    ((ArrayAccess)rhs).getIndices();
                            List<Expression> normalized_indices =
                                    new LinkedList<Expression>();
                            for (Expression index : indices) {
                                normalized_indices.add(
                                        normalizePointsTo(index));
                            }
                            normalized_name = new AccessExpression(
                                    lhs, AccessOperator.MEMBER_ACCESS,
                                    normalized_name);
                            acc = new ArrayAccess(normalized_name,
                                                  normalized_indices);
                        } else {
                            acc = new AccessExpression(lhs,
                                                       AccessOperator.
                                                       MEMBER_ACCESS, rhs);
                        }
                        acc.setParens(true);
                        normalized = new UnaryExpression(
                                UnaryOperator.ADDRESS_OF, acc);
                    } else {
                        normalized = new AccessExpression(
                                lhs, AccessOperator.MEMBER_ACCESS, rhs);
                    }
                } else if (access.getOperator() ==
                           AccessOperator.MEMBER_DEREF_ACCESS) {
                    UnaryExpression unary_rhs =
                            new UnaryExpression(UnaryOperator.DEREFERENCE, rhs);
                    normalized = new AccessExpression(
                            lhs, AccessOperator.MEMBER_ACCESS, unary_rhs);
                // Examples
                // (x->)y
                // (*x)->(y)
                } else if (access.getOperator() ==
                           AccessOperator.POINTER_ACCESS) {
                    UnaryExpression unary_lhs =
                            new UnaryExpression(UnaryOperator.DEREFERENCE, lhs);
                    normalized = new AccessExpression(
                            unary_lhs, AccessOperator.MEMBER_ACCESS, rhs);
                // Examples
                // (x->*)y
                } else if (access.getOperator() ==
                           AccessOperator.POINTER_MEMBER_ACCESS) {
                    UnaryExpression unary_lhs =
                            new UnaryExpression(UnaryOperator.DEREFERENCE, lhs);
                    UnaryExpression unary_rhs =
                            new UnaryExpression(UnaryOperator.DEREFERENCE, rhs);
                    normalized = new AccessExpression(
                            unary_lhs, AccessOperator.MEMBER_ACCESS, unary_rhs);
                }
                normalized.setParens(true);
                swap_pairs.put(access, normalized);
            } else if (o instanceof ArrayAccess) {
                Expression name = ((ArrayAccess)o).getArrayName();
                // If the variable being used as an array has not been
                // declared an array, it must be a pointer to an array
                // If its name isn't already being dereferenced, create
                // a normalized array access operation
                if ((!(SymbolTools.isArray(SymbolTools.getSymbolOf(name))) ||
                    (SymbolTools.isFormal(SymbolTools.getSymbolOf(name)))) &&
                    !(name instanceof UnaryExpression)) {
                    // This is an array access via a pointer 
                    // pointing to that array
                    // convert from pointer[i] to (*pointer)[i]
                    Expression normalized_name = normalizePointsTo(name);
                    List<Expression> indices = ((ArrayAccess)o).getIndices();
                    List<Expression> normalized_indices =
                            new LinkedList<Expression>();
                    for (Expression index : indices) {
                        normalized_indices.add(normalizePointsTo(index));
                    }
                    Expression new_name = normalized_name;
                    for (int i = normalized_indices.size(); i > 0; i--) {
                        new_name = new UnaryExpression(
                                UnaryOperator.DEREFERENCE, new_name);
                    }
                    new_name.setParens(true);
                    normalized = new ArrayAccess(new_name, normalized_indices);
                } else {
                    normalized = o.clone();
                }
                // Now, if this array access is not through 
                // a pointer variable
                if (SymbolTools.isArray(SymbolTools.getSymbolOf(name))) {
                    // If the expression is an array access such that it 
                    // represents a sub-array pointer, normalize it
                    // e.g.
                    // int z[5][5], *y;
                    // y = z[4];
                    // The actual semantics of this assignment are:
                    // y = &(z[4][0]);
                    int dimensions = 0;
                    List<ArraySpecifier> array_specs =
                        (SymbolTools.getSymbolOf(name)).getArraySpecifiers();
                    // Adding up dimensions for all trailing array specs
                    // TODO:
                    // Check when the list of array specifiers is 
                    // greater than size=1
                    for (ArraySpecifier aspec : array_specs) {
                        dimensions += aspec.getNumDimensions();
                    }
                    // If the array access contains less dimensions than the 
                    // declaration, it means we're looking at a pointer that 
                    // points inside the array aggregate structure
                    if (((ArrayAccess)o).getNumIndices() < dimensions) {
                        ArrayAccess a = ((ArrayAccess)normalized).clone();
                        a.addIndex(new IntegerLiteral(0));
                        normalized = new UnaryExpression(
                                UnaryOperator.ADDRESS_OF, a);
                    }
                }
                swap_pairs.put(o, normalized);
            } else if (o instanceof Identifier) {
                if (SymbolTools.isArray(SymbolTools.getSymbolOf(o))) {
                    Traversable parent = o.getParent();
                    if (!(parent instanceof ArrayAccess)) {
                        ArrayAccess a = new ArrayAccess(
                                o.clone(), new IntegerLiteral(0));
                        normalized = new UnaryExpression(
                                UnaryOperator.ADDRESS_OF, a);
                        swap_pairs.put(o, normalized);
                    }
                }
            }
        }
        for (Expression expr : swap_pairs.keySet()) {
            List<Expression> cloned_substitutes = e_clone.findExpression(expr);
            // We substitute only the first occurrence with the normalized
            // version as others will be found subsequently
            Expression expr_clone = cloned_substitutes.get(0);
            // This is e_clone itself, or else it would be traversable 
            // upward
            if (expr_clone.getParent() == null) {
                e_clone = swap_pairs.get(expr);
            } else {
                expr_clone.swapWith(swap_pairs.get(expr));
            }
        }
        return e_clone;
    }

    /**
    * Use this to annotate a traversable object with the statement-based
    * points-to relationships identified inside the traversable Annotations are
    * inserted as comments before each statement
    * @param t The traversable to annotate
    * @param pointsto Map from statement to its domain (relationships)
    */
    protected static void annotatePointsTo(Traversable t, Map pointsto) {
        DFIterator<Statement> iter =
                new DFIterator<Statement>(t, Statement.class);
        while (iter.hasNext()) {
            Statement s = iter.next();
            Domain domain = (Domain)pointsto.get(s);
            if (domain != null) {
                String annot_string = "";
                annot_string += domain.toString();
                if (!annot_string.equals("")) {
                    CommentAnnotation annot =
                            new CommentAnnotation(annot_string);
                    annot.setOneLiner(true);
                    s.annotateBefore(annot);
                }
            }
        }
    }

    private static boolean checkPointerArithmetic(Traversable t) {
        boolean pointer_arithmetic = false;
        // Binary operators that can provide address calculation
        // are also considered as pointer arithmetic if one of the
        // operands is a pointer
        // e.g. (a+b)->x
        // Here (a+b) result in a new address value that 
        // supposedly points somewhere into a struct to member x
        // see static binary_ops
        DFIterator<Expression> iter =
                new DFIterator<Expression>(t, Expression.class);
        while (iter.hasNext()) {
            Expression o = iter.next();
            if (o instanceof UnaryExpression) {
                UnaryExpression u =
                        (UnaryExpression)normalizePointsTo(o);
                if (UnaryOperator.hasSideEffects(u.getOperator())) {
                    Expression e = u;
                    while (e instanceof UnaryExpression &&
                           UnaryOperator.hasSideEffects(
                                ((UnaryExpression)e).getOperator())) {
                        e = ((UnaryExpression)e).getExpression();
                    }
                    if (isPointer(exprToLocation(e))) {
                        pointer_arithmetic = true;
                        break;
                    }
                }
            } else if (o instanceof BinaryExpression) {
                BinaryOperator op = ((BinaryExpression)o).getOperator();
                if (binary_ops.contains(op)) {
                    Expression elhs =
                            normalizePointsTo(((BinaryExpression)o).getLHS());
                    Expression erhs =
                            normalizePointsTo(((BinaryExpression)o).getRHS());
                    if (elhs instanceof Typecast) {
                        List<Traversable> children = elhs.getChildren();
                        if (children.size() == 1) {
                            elhs = (Expression)children.get(0);
                        } else {
                            continue;
                        }
                    }
                    if (erhs instanceof Typecast) {
                        List<Traversable> children = erhs.getChildren();
                        if (children.size() == 1) {
                            erhs = (Expression)children.get(0);
                        } else {
                            continue;
                        }
                    }
                    Symbol lhs = exprToLocation(elhs);
                    Symbol rhs = exprToLocation(erhs);
                    if ((isPointer(lhs) && (SymbolTools.isInteger(rhs) ||
                                           erhs instanceof IntegerLiteral)) ||
                        (isPointer(rhs) && (SymbolTools.isInteger(lhs) ||
                                           elhs instanceof IntegerLiteral))) {
                        // This means there's some computation going on
                        // involving pointers
                        pointer_arithmetic = true;
                        break;
                    } else if (elhs instanceof UnaryExpression &&
                               ((UnaryExpression)elhs).getOperator() ==
                               UnaryOperator.ADDRESS_OF) {
                        if (erhs instanceof IntegerLiteral ||
                            SymbolTools.isInteger(rhs)) {
                            pointer_arithmetic = true;
                            break;
                        }
                    } else if (erhs instanceof UnaryExpression &&
                               ((UnaryExpression)erhs).getOperator() ==
                               UnaryOperator.ADDRESS_OF) {
                        if (elhs instanceof IntegerLiteral ||
                            SymbolTools.isInteger(lhs)) {
                            pointer_arithmetic = true;
                            break;
                        }
                    }
                }
            }
        }
        return pointer_arithmetic;
    }

    // Handles pointer initialization at the start of 
    // entering a new scope
    @SuppressWarnings("unchecked")
    private static Domain enterScope(
            DFANode node, Domain input, IPANode proc_node, Map stmt_domain) {
        boolean points_to_universe = false;
        Domain out_domain = null;
        Domain in_domain = null;
        in_domain = input.clone();
        SymbolTable symtab = node.getData("symbol-entry");
        if (symtab == null) {
            return out_domain;
        } else if (symtab instanceof CompoundStatement ||
                   symtab instanceof Procedure ||
                   symtab instanceof TranslationUnit) {
            DFIterator<Traversable> iter = new DFIterator<Traversable>(symtab);
            while (iter.hasNext()) {
                Traversable o = iter.next();
                if (o instanceof DeclarationStatement) {
                    stmt_domain.put((DeclarationStatement)o, in_domain);
                    continue;
                }
                if (!(o instanceof Symbol)) {
                    continue;
                }
                Symbol s = (Symbol)o;
                if (!(s instanceof VariableDeclarator)) {
                    continue;
                }
                Initializer init = ((VariableDeclarator)s).getInitializer();
                if (init != null) {
                    Statement enclosing_stmt = IRTools.getAncestorOfType(
                            init, Statement.class);
                    Symbol lhs_symbol = s;
                    List<Traversable> init_vals = init.getChildren();
                    if (SymbolTools.isPointer(lhs_symbol)) {
                        Domain gen = new PointsToDomain();
                        for (int i = (init_vals.size() - 1); i >= 0; i--) {
                            Traversable t = init_vals.get(i);
                            if (t instanceof Expression) {
                                Expression rhs = (Expression)t;
                                Expression rhs_local = normalizePointsTo(rhs);
                                if (IRTools.containsClass(
                                            rhs, FunctionCall.class)) {
                                    if (proc_node != null) {
                                        // ----- OBTAIN THE R-LOCATION SET ---- 
                                        // Get the outermost function call in
                                        // the rhs, this is the call site that
                                        // returns the value being assigned to
                                        // the lhs
                                        DFIterator<FunctionCall> dfs_iter =
                                                new DFIterator<FunctionCall>(
                                                rhs, FunctionCall.class);
                                        FunctionCall call = dfs_iter.next();
                                        Map<Symbol, Boolean> r_locations =
                                                new HashMap<Symbol, Boolean>();
                                        Set<PointsToRel> return_result = null;
                                        return_result = IPPointsToAnalysis.
                                                getReturnRelations(
                                                proc_node.getCallSite(call));
                                        if (return_result == null) {
                                            gen = Universe.getUniverse();
                                        } else {
                                            for (PointsToRel p_rel :
                                                 return_result) {
                                                r_locations.put(
                                                    p_rel.getPointedToSymbol(),
                                                    p_rel.isDefinite());
                                            }
                                            PointsToDomain init_domain =
                                                    new PointsToDomain();
                                            for (Symbol rhs_symbol :
                                                 r_locations.keySet()) {
                                                PointsToRel p_rel =
                                                  new PointsToRel(
                                                  lhs_symbol, rhs_symbol,
                                                  r_locations.get(rhs_symbol));
                                                init_domain.addRel(p_rel);
                                            }
                                            gen = gen.union(init_domain);
                                        }
                                    } else {
                                        gen = Universe.getUniverse();
                                    }
                                } else {
                                    // Now compute the r-location set
                                    Map<Symbol, Boolean> r_locations =
                                            new HashMap<Symbol, Boolean>();
                                    points_to_universe |= computeRlocations(
                                            r_locations, rhs_local,
                                            enclosing_stmt, in_domain);
                                    if (points_to_universe) {
                                        gen = Universe.getUniverse();
                                    // We must generate points to information
                                    } else {
                                        PointsToDomain init_domain =
                                                new PointsToDomain();
                                        for (Symbol rhs_symbol :
                                             r_locations.keySet()) {
                                            PointsToRel p_rel = new PointsToRel(
                                                   lhs_symbol, rhs_symbol,
                                                   r_locations.get(rhs_symbol));
                                            init_domain.addRel(p_rel);
                                        }
                                        gen = gen.union(init_domain);
                                    }
                                }
                            } else {
                                gen = Universe.getUniverse();
                            }
                        }
                        out_domain = gen.union(in_domain);
                    } else {
                        // Not even a pointer symbol, output 
                        // is same as input
                        out_domain = in_domain.clone();
                    }
                } else {
                    out_domain = in_domain.clone();
                }
                // For the next symbol/declaration/initializer, the in_domain
                // must be the current out_domain
                in_domain = out_domain.clone();
            }
        }
        return out_domain;
    }

    /**
    * Returns the abstract stack location associated with the given expression.
    * Notice that this method returns null if the given expression does not
    * represent an abstract stack location, e.g., +e, !e, ...,.
    */
    protected static Symbol exprToLocation(Expression e) {
        Symbol ret = null;
        if (e instanceof Identifier) {
            ret = ((Identifier)e).getSymbol();
        } else if (e instanceof ArrayAccess) {
            ret = exprToLocation(((ArrayAccess)e).getArrayName());
        } else if (e instanceof AccessExpression) {
            ret = new AccessSymbol((AccessExpression)e);
        } else if (e instanceof UnaryExpression) {
            UnaryOperator uop = ((UnaryExpression)e).getOperator();
            Expression expr = ((UnaryExpression)e).getExpression();
            if (uop == UnaryOperator.DEREFERENCE) {
                ret = exprToLocation(expr);
                if (ret != null) {
                    ret = DerefSymbol.get(ret);
                }
            } else if (uop == UnaryOperator.POST_DECREMENT ||
                       uop == UnaryOperator.POST_INCREMENT ||
                       uop == UnaryOperator.PRE_DECREMENT ||
                       uop == UnaryOperator.PRE_INCREMENT) {
                ret = exprToLocation(expr);
            }
        } else if (e instanceof Typecast) {
            ret = exprToLocation(((Typecast)e).getExpression());
        }
        if (ret == null) {
            PrintTools.printlnStatus(1, "[WARNING]", e,
                                     "does not have a location");
        }
        return ret;
    }

    /**
    * This functionality is specifically provided separately from SymbolTools
    * functionality. We consider variables types for Points-To analysis related
    * symbols such as Deref Symbols as also Abstract Locations, thus providing
    * accurate information to the analyzer. Use only if dealing with these 
    * constructs.
    * @param symbol
    * @return TRUE if the symbol represents a pointer location
    */
    protected static boolean isPointer(Symbol symbol) {
        if (symbol == null) {
            return false;
        }
        List specs = IPPointsToAnalysis.getTypeSpecifiers(symbol);
        if (specs == null) {
            return false;
        }
        for (Object o : specs) {
            if (o instanceof PointerSpecifier) {
                return true;
            }
        }
        return false;
    }

    private static boolean isNullPointer(Expression e) {
        boolean ret = false;
        if (e instanceof IntegerLiteral &&
            ((IntegerLiteral)e).getValue() == 0) {
            ret = true;
        } else if (e instanceof Identifier &&
                   (((Identifier)e).getName()).equals("NULL")) {
            ret = true;
        } else if (e instanceof Typecast) {
            List specs = SymbolTools.getExpressionType(e);
            if (specs.contains(PointerSpecifier.UNQUALIFIED)) {
            /* Type is not important if the actual value is 0.
            if (specs.contains(Specifier.VOID) && 
                specs.contains(PointerSpecifier.UNQUALIFIED))
            */
                List<Traversable> exprs = e.getChildren();
                if (exprs.size() == 1) {
                    Expression child = (Expression)exprs.get(0);
                    if (child instanceof IntegerLiteral &&
                        ((IntegerLiteral)child).getValue() == 0) {
                        // ((void *)0)
                        ret = true;
                    }
                }
            }
        }
        return ret;
    }

    /**
    * Attemps to convert pointer arithmetic expression into an array access
    * if possible. Currently handles simple binary expressions that involve 
    * a pointer and an integer value
    * Returns null if unable to handle other cases
    * @param e the input expression.
    * @return the converted expression or null.
    */
    protected static Expression normalizePointerArithmetic(Expression e) {
        Expression e_clone = null;
        // Convert:
        // p++ -> p = &(p[1]);
        // p+=3 -> p = &(p[3]);
        // p = a+10 -> p = &(a[10]);
        if (e instanceof UnaryExpression) {
            return null;
        } else if (e instanceof BinaryExpression) {
            BinaryExpression binary = (BinaryExpression)e;
            Expression pointer_expr = null;
            Expression int_literal = null;
            if (binary.getLHS()instanceof IntegerLiteral ||
                SymbolTools.isInteger(
                    SymbolTools.getSymbolOf((binary.getLHS())))) {
                int_literal = binary.getLHS().clone();
                pointer_expr = binary.getRHS().clone();
            } else if (binary.getRHS()instanceof IntegerLiteral ||
                       SymbolTools.isInteger(
                            SymbolTools.getSymbolOf((binary.getRHS())))) {
                pointer_expr = binary.getLHS().clone();
                int_literal = binary.getRHS().clone();
            } else {
                return null;
            }
            if (binary.getOperator() == BinaryOperator.SUBTRACT) {
                if (int_literal instanceof IntegerLiteral) {
                    ((IntegerLiteral)int_literal).setValue(
                            ((IntegerLiteral) int_literal).getValue() * (-1));
                } else {
                    int_literal = new UnaryExpression(UnaryOperator.MINUS,
                                                      int_literal);
                }
            } else if (binary.getOperator() == BinaryOperator.ADD) {
                ;
            } else {
                return null;
            }
            Expression unary = null;
            if (IRTools.containsClass(pointer_expr, ArrayAccess.class)) {
                Expression normalized_expr = pointer_expr.clone();
                DFIterator<ArrayAccess> acc_iter = new DFIterator<ArrayAccess>(
                        normalized_expr, ArrayAccess.class);
                ArrayAccess acc = acc_iter.next();
                Expression last_index = acc.getIndex(acc.getNumIndices() - 1);
                Expression new_last_index = new BinaryExpression(
                        last_index.clone(), binary.getOperator(), int_literal);
                acc.setIndex(acc.getNumIndices() - 1, new_last_index);
                unary = normalized_expr;
            } else {
                ArrayAccess new_acc = new ArrayAccess(pointer_expr,int_literal);
                unary = new UnaryExpression(UnaryOperator.ADDRESS_OF, new_acc);
            }
            e_clone = unary;
        } else {
            return null;
        }
        return e_clone;
    }

    /**
    * API to create a map from Statement to Domain where every statement is
    * assigned the value of Universe Domain.
    * @param t The traversable inside of which this assignment must happen
    * @return The universe map 
    */
    protected static Map createUniverseMap(Traversable t) {
        DFIterator<Statement> iter =
                new DFIterator<Statement>(t, Statement.class);
        Domain universe = Universe.getUniverse();
        Map<Statement, Domain> universe_map = new HashMap<Statement, Domain>();
        while (iter.hasNext()) {
            universe_map.put(iter.next(), universe);
        }
        return universe_map;
    }
}
